use crate::State;
use std::str::FromStr;
use lang::ast::*;
use lalrpop_util::ParseError;

grammar(state: &mut State);

pub Expr: Expr = {
    <t:Term> => Expr::Term(t),
    <e:Expr> "[" <i:Expr> "]" => Expr::Binop(Binop::Index, Box::new(e), Box::new(i)),
    FnCall,
}

pub Term: Term = {
    <s:Symbol> => Term::Symbol(s),
    <n:Number> => Term::Num(n),
    <s:String> => Term::Str(s),
};

FnCall: Expr = {
    <e: Expr> "(" <es: Exprs?> ")" => {
        match es {
            None => Expr::Call(Box::new(e), vec![]),
            Some(es) => Expr::Call(Box::new(e), es),
        }
    },
}

Exprs: Vec<Expr> = {
    <es: Exprs> "," <e: Expr> => {
        let mut es = es;
        es.push(e);
        es
    },
    Expr => vec![<>],
}

Number: Num = {
    r"[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?" =>? i32::from_str(<>).map(Num::Int).or(
        f64::from_str(<>).map(Num::Double).map_err(|_| ParseError::User {
            error: "Invalid number"
        })
    ),
}

String: String = {
    <s:r"'[^\n]*'"> => s[1..s.len()-1].to_string(),
    <s:r#""[^\n]*""#> => s[1..s.len()-1].to_string(),
}

Symbol: Symbol = {
    <s:r"[a-zA-Z_$][a-zA-Z0-9_$]*"> => {
        Symbol { id: state.next_symbol_id(), name: s.to_string() }
    },
}
