use crate::State;
use std::str::FromStr;
use lang::ast::*;
use lalrpop_util::ParseError;

grammar(state: &mut State);

pub Expr: Expr = {
    AndExpr,
}

AndExpr: Expr = {
    <e:AndExpr> "&&" <a:BitOrExpr> => Expr::Binop(Binop::And, Box::new(e), Box::new(a)),
    BitOrExpr,
}

BitOrExpr: Expr = {
    <e:BitOrExpr> "|" <a:XorExpr> => Expr::Binop(Binop::BitOr, Box::new(e), Box::new(a)),
    XorExpr,
}

XorExpr: Expr = {
    <e:XorExpr> "^" <a:BitAndExpr> => Expr::Binop(Binop::Xor, Box::new(e), Box::new(a)),
    BitAndExpr,
}

BitAndExpr: Expr = {
    <e:BitAndExpr> "&" <a:EqExpr> => Expr::Binop(Binop::BitAnd, Box::new(e), Box::new(a)),
    EqExpr,
}

EqExpr: Expr = {
    <e:EqExpr> "==" <a:RelationExpr> => Expr::Binop(Binop::Eq, Box::new(e), Box::new(a)),
    <e:EqExpr> "!=" <a:RelationExpr> => Expr::Binop(Binop::Neq, Box::new(e), Box::new(a)),
    RelationExpr,
}

RelationExpr: Expr = {
    <e:RelationExpr> "<" <u:ShiftExpr> => Expr::Binop(Binop::Lt, Box::new(e), Box::new(u)),
    <e:RelationExpr> ">" <u:ShiftExpr> => Expr::Binop(Binop::Gt, Box::new(e), Box::new(u)),
    <e:RelationExpr> "<=" <u:ShiftExpr> => Expr::Binop(Binop::Lte, Box::new(e), Box::new(u)),
    <e:RelationExpr> ">=" <u:ShiftExpr> => Expr::Binop(Binop::Gte, Box::new(e), Box::new(u)),
    ShiftExpr,
}

ShiftExpr: Expr = {
    <e:ShiftExpr> "<<" <a:AddSubExpr> => Expr::Binop(Binop::Shl, Box::new(e), Box::new(a)),
    <e:ShiftExpr> ">>" <a:AddSubExpr> => Expr::Binop(Binop::Shr, Box::new(e), Box::new(a)),
    AddSubExpr,
}

AddSubExpr: Expr = {
    <e:AddSubExpr> "+" <m:MulDivModExpr> => Expr::Binop(Binop::Add, Box::new(e), Box::new(m)),
    <e:AddSubExpr> "-" <m:MulDivModExpr> => Expr::Binop(Binop::Sub, Box::new(e), Box::new(m)),
    MulDivModExpr,
}

MulDivModExpr: Expr = {
    <e:MulDivModExpr> "*" <u:UnaryExpr> => Expr::Binop(Binop::Mul, Box::new(e), Box::new(u)),
    <e:MulDivModExpr> "/" <u:UnaryExpr> => Expr::Binop(Binop::Div, Box::new(e), Box::new(u)),
    <e:MulDivModExpr> "%" <u:UnaryExpr> => Expr::Binop(Binop::Mod, Box::new(e), Box::new(u)),
    UnaryExpr,
}

UnaryExpr: Expr = {
    "typeof" <e:UnaryExpr> => Expr::Unop(Unop::Typeof, Box::new(e)),
    PostfixExpr,
}

PostfixExpr: Expr = {
    <t:Term> => Expr::Term(t),
    <e:PostfixExpr> "[" <i:Expr> "]" => Expr::Binop(Binop::Index, Box::new(e), Box::new(i)),
    FnCall,
    "(" <e:Expr> ")" => e,
    <e:PostfixExpr> "." <s:Symbol> => Expr::Binop(Binop::Member, Box::new(e), Box::new(Expr::Term(Term::Symbol(s)))),
}

pub Term: Term = {
    <s:Symbol> => Term::Symbol(s),
    <n:Number> => Term::Num(n),
    <s:String> => Term::Str(s),
};

FnCall: Expr = {
    <e:PostfixExpr> "(" <es:Exprs?> ")" => {
        match es {
            None => Expr::Call(Box::new(e), vec![]),
            Some(es) => Expr::Call(Box::new(e), es),
        }
    },
}

Exprs: Vec<Expr> = {
    <es:Exprs> "," <e:Expr> => {
        let mut es = es;
        es.push(e);
        es
    },
    Expr => vec![<>],
}

Number: Num = {
    r"[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?" =>? i32::from_str(<>).map(Num::Int).or(
        f64::from_str(<>).map(Num::Double).map_err(|_| ParseError::User {
            error: "Invalid number"
        })
    ),
}

String: String = {
    <s:r"'[^\n]*'"> => s[1..s.len()-1].to_string(),
    <s:r#""[^\n]*""#> => s[1..s.len()-1].to_string(),
}

Symbol: Symbol = {
    <s:r"[a-zA-Z_$][a-zA-Z0-9_$]*"> => {
        Symbol { id: state.next_symbol_id(), name: s.to_string() }
    },
}
